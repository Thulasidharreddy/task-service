/*
 * This file is generated by jOOQ.
 */
package com.neurasim.jooq.performance_schema.tables.pojos;


import com.neurasim.jooq.performance_schema.enums.ReplicationConnectionConfigurationAutoPosition;
import com.neurasim.jooq.performance_schema.enums.ReplicationConnectionConfigurationGetPublicKey;
import com.neurasim.jooq.performance_schema.enums.ReplicationConnectionConfigurationGtidOnly;
import com.neurasim.jooq.performance_schema.enums.ReplicationConnectionConfigurationSourceConnectionAutoFailover;
import com.neurasim.jooq.performance_schema.enums.ReplicationConnectionConfigurationSslAllowed;
import com.neurasim.jooq.performance_schema.enums.ReplicationConnectionConfigurationSslVerifyServerCertificate;

import java.io.Serializable;

import org.jooq.types.ULong;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class ReplicationConnectionConfiguration implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String channelName;
    private final String host;
    private final Integer port;
    private final String user;
    private final String networkInterface;
    private final ReplicationConnectionConfigurationAutoPosition autoPosition;
    private final ReplicationConnectionConfigurationSslAllowed sslAllowed;
    private final String sslCaFile;
    private final String sslCaPath;
    private final String sslCertificate;
    private final String sslCipher;
    private final String sslKey;
    private final ReplicationConnectionConfigurationSslVerifyServerCertificate sslVerifyServerCertificate;
    private final String sslCrlFile;
    private final String sslCrlPath;
    private final Integer connectionRetryInterval;
    private final ULong connectionRetryCount;
    private final Double heartbeatInterval;
    private final String tlsVersion;
    private final String publicKeyPath;
    private final ReplicationConnectionConfigurationGetPublicKey getPublicKey;
    private final String networkNamespace;
    private final String compressionAlgorithm;
    private final Integer zstdCompressionLevel;
    private final String tlsCiphersuites;
    private final ReplicationConnectionConfigurationSourceConnectionAutoFailover sourceConnectionAutoFailover;
    private final ReplicationConnectionConfigurationGtidOnly gtidOnly;

    public ReplicationConnectionConfiguration(ReplicationConnectionConfiguration value) {
        this.channelName = value.channelName;
        this.host = value.host;
        this.port = value.port;
        this.user = value.user;
        this.networkInterface = value.networkInterface;
        this.autoPosition = value.autoPosition;
        this.sslAllowed = value.sslAllowed;
        this.sslCaFile = value.sslCaFile;
        this.sslCaPath = value.sslCaPath;
        this.sslCertificate = value.sslCertificate;
        this.sslCipher = value.sslCipher;
        this.sslKey = value.sslKey;
        this.sslVerifyServerCertificate = value.sslVerifyServerCertificate;
        this.sslCrlFile = value.sslCrlFile;
        this.sslCrlPath = value.sslCrlPath;
        this.connectionRetryInterval = value.connectionRetryInterval;
        this.connectionRetryCount = value.connectionRetryCount;
        this.heartbeatInterval = value.heartbeatInterval;
        this.tlsVersion = value.tlsVersion;
        this.publicKeyPath = value.publicKeyPath;
        this.getPublicKey = value.getPublicKey;
        this.networkNamespace = value.networkNamespace;
        this.compressionAlgorithm = value.compressionAlgorithm;
        this.zstdCompressionLevel = value.zstdCompressionLevel;
        this.tlsCiphersuites = value.tlsCiphersuites;
        this.sourceConnectionAutoFailover = value.sourceConnectionAutoFailover;
        this.gtidOnly = value.gtidOnly;
    }

    public ReplicationConnectionConfiguration(
        String channelName,
        String host,
        Integer port,
        String user,
        String networkInterface,
        ReplicationConnectionConfigurationAutoPosition autoPosition,
        ReplicationConnectionConfigurationSslAllowed sslAllowed,
        String sslCaFile,
        String sslCaPath,
        String sslCertificate,
        String sslCipher,
        String sslKey,
        ReplicationConnectionConfigurationSslVerifyServerCertificate sslVerifyServerCertificate,
        String sslCrlFile,
        String sslCrlPath,
        Integer connectionRetryInterval,
        ULong connectionRetryCount,
        Double heartbeatInterval,
        String tlsVersion,
        String publicKeyPath,
        ReplicationConnectionConfigurationGetPublicKey getPublicKey,
        String networkNamespace,
        String compressionAlgorithm,
        Integer zstdCompressionLevel,
        String tlsCiphersuites,
        ReplicationConnectionConfigurationSourceConnectionAutoFailover sourceConnectionAutoFailover,
        ReplicationConnectionConfigurationGtidOnly gtidOnly
    ) {
        this.channelName = channelName;
        this.host = host;
        this.port = port;
        this.user = user;
        this.networkInterface = networkInterface;
        this.autoPosition = autoPosition;
        this.sslAllowed = sslAllowed;
        this.sslCaFile = sslCaFile;
        this.sslCaPath = sslCaPath;
        this.sslCertificate = sslCertificate;
        this.sslCipher = sslCipher;
        this.sslKey = sslKey;
        this.sslVerifyServerCertificate = sslVerifyServerCertificate;
        this.sslCrlFile = sslCrlFile;
        this.sslCrlPath = sslCrlPath;
        this.connectionRetryInterval = connectionRetryInterval;
        this.connectionRetryCount = connectionRetryCount;
        this.heartbeatInterval = heartbeatInterval;
        this.tlsVersion = tlsVersion;
        this.publicKeyPath = publicKeyPath;
        this.getPublicKey = getPublicKey;
        this.networkNamespace = networkNamespace;
        this.compressionAlgorithm = compressionAlgorithm;
        this.zstdCompressionLevel = zstdCompressionLevel;
        this.tlsCiphersuites = tlsCiphersuites;
        this.sourceConnectionAutoFailover = sourceConnectionAutoFailover;
        this.gtidOnly = gtidOnly;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.CHANNEL_NAME</code>.
     */
    public String getChannelName() {
        return this.channelName;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.HOST</code>.
     */
    public String getHost() {
        return this.host;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.PORT</code>.
     */
    public Integer getPort() {
        return this.port;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.USER</code>.
     */
    public String getUser() {
        return this.user;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.NETWORK_INTERFACE</code>.
     */
    public String getNetworkInterface() {
        return this.networkInterface;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.AUTO_POSITION</code>.
     */
    public ReplicationConnectionConfigurationAutoPosition getAutoPosition() {
        return this.autoPosition;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_ALLOWED</code>.
     */
    public ReplicationConnectionConfigurationSslAllowed getSslAllowed() {
        return this.sslAllowed;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_CA_FILE</code>.
     */
    public String getSslCaFile() {
        return this.sslCaFile;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_CA_PATH</code>.
     */
    public String getSslCaPath() {
        return this.sslCaPath;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_CERTIFICATE</code>.
     */
    public String getSslCertificate() {
        return this.sslCertificate;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_CIPHER</code>.
     */
    public String getSslCipher() {
        return this.sslCipher;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_KEY</code>.
     */
    public String getSslKey() {
        return this.sslKey;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_VERIFY_SERVER_CERTIFICATE</code>.
     */
    public ReplicationConnectionConfigurationSslVerifyServerCertificate getSslVerifyServerCertificate() {
        return this.sslVerifyServerCertificate;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_CRL_FILE</code>.
     */
    public String getSslCrlFile() {
        return this.sslCrlFile;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SSL_CRL_PATH</code>.
     */
    public String getSslCrlPath() {
        return this.sslCrlPath;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.CONNECTION_RETRY_INTERVAL</code>.
     */
    public Integer getConnectionRetryInterval() {
        return this.connectionRetryInterval;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.CONNECTION_RETRY_COUNT</code>.
     */
    public ULong getConnectionRetryCount() {
        return this.connectionRetryCount;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.HEARTBEAT_INTERVAL</code>.
     * Number of seconds after which a heartbeat will be sent .
     */
    public Double getHeartbeatInterval() {
        return this.heartbeatInterval;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.TLS_VERSION</code>.
     */
    public String getTlsVersion() {
        return this.tlsVersion;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.PUBLIC_KEY_PATH</code>.
     */
    public String getPublicKeyPath() {
        return this.publicKeyPath;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.GET_PUBLIC_KEY</code>.
     */
    public ReplicationConnectionConfigurationGetPublicKey getGetPublicKey() {
        return this.getPublicKey;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.NETWORK_NAMESPACE</code>.
     */
    public String getNetworkNamespace() {
        return this.networkNamespace;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.COMPRESSION_ALGORITHM</code>.
     * Compression algorithm used for data transfer between master and slave.
     */
    public String getCompressionAlgorithm() {
        return this.compressionAlgorithm;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.ZSTD_COMPRESSION_LEVEL</code>.
     * Compression level associated with zstd compression algorithm.
     */
    public Integer getZstdCompressionLevel() {
        return this.zstdCompressionLevel;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.TLS_CIPHERSUITES</code>.
     */
    public String getTlsCiphersuites() {
        return this.tlsCiphersuites;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.SOURCE_CONNECTION_AUTO_FAILOVER</code>.
     */
    public ReplicationConnectionConfigurationSourceConnectionAutoFailover getSourceConnectionAutoFailover() {
        return this.sourceConnectionAutoFailover;
    }

    /**
     * Getter for
     * <code>performance_schema.replication_connection_configuration.GTID_ONLY</code>.
     * Indicates if this channel only uses GTIDs and does not persist positions.
     */
    public ReplicationConnectionConfigurationGtidOnly getGtidOnly() {
        return this.gtidOnly;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        final ReplicationConnectionConfiguration other = (ReplicationConnectionConfiguration) obj;
        if (this.channelName == null) {
            if (other.channelName != null)
                return false;
        }
        else if (!this.channelName.equals(other.channelName))
            return false;
        if (this.host == null) {
            if (other.host != null)
                return false;
        }
        else if (!this.host.equals(other.host))
            return false;
        if (this.port == null) {
            if (other.port != null)
                return false;
        }
        else if (!this.port.equals(other.port))
            return false;
        if (this.user == null) {
            if (other.user != null)
                return false;
        }
        else if (!this.user.equals(other.user))
            return false;
        if (this.networkInterface == null) {
            if (other.networkInterface != null)
                return false;
        }
        else if (!this.networkInterface.equals(other.networkInterface))
            return false;
        if (this.autoPosition == null) {
            if (other.autoPosition != null)
                return false;
        }
        else if (!this.autoPosition.equals(other.autoPosition))
            return false;
        if (this.sslAllowed == null) {
            if (other.sslAllowed != null)
                return false;
        }
        else if (!this.sslAllowed.equals(other.sslAllowed))
            return false;
        if (this.sslCaFile == null) {
            if (other.sslCaFile != null)
                return false;
        }
        else if (!this.sslCaFile.equals(other.sslCaFile))
            return false;
        if (this.sslCaPath == null) {
            if (other.sslCaPath != null)
                return false;
        }
        else if (!this.sslCaPath.equals(other.sslCaPath))
            return false;
        if (this.sslCertificate == null) {
            if (other.sslCertificate != null)
                return false;
        }
        else if (!this.sslCertificate.equals(other.sslCertificate))
            return false;
        if (this.sslCipher == null) {
            if (other.sslCipher != null)
                return false;
        }
        else if (!this.sslCipher.equals(other.sslCipher))
            return false;
        if (this.sslKey == null) {
            if (other.sslKey != null)
                return false;
        }
        else if (!this.sslKey.equals(other.sslKey))
            return false;
        if (this.sslVerifyServerCertificate == null) {
            if (other.sslVerifyServerCertificate != null)
                return false;
        }
        else if (!this.sslVerifyServerCertificate.equals(other.sslVerifyServerCertificate))
            return false;
        if (this.sslCrlFile == null) {
            if (other.sslCrlFile != null)
                return false;
        }
        else if (!this.sslCrlFile.equals(other.sslCrlFile))
            return false;
        if (this.sslCrlPath == null) {
            if (other.sslCrlPath != null)
                return false;
        }
        else if (!this.sslCrlPath.equals(other.sslCrlPath))
            return false;
        if (this.connectionRetryInterval == null) {
            if (other.connectionRetryInterval != null)
                return false;
        }
        else if (!this.connectionRetryInterval.equals(other.connectionRetryInterval))
            return false;
        if (this.connectionRetryCount == null) {
            if (other.connectionRetryCount != null)
                return false;
        }
        else if (!this.connectionRetryCount.equals(other.connectionRetryCount))
            return false;
        if (this.heartbeatInterval == null) {
            if (other.heartbeatInterval != null)
                return false;
        }
        else if (!this.heartbeatInterval.equals(other.heartbeatInterval))
            return false;
        if (this.tlsVersion == null) {
            if (other.tlsVersion != null)
                return false;
        }
        else if (!this.tlsVersion.equals(other.tlsVersion))
            return false;
        if (this.publicKeyPath == null) {
            if (other.publicKeyPath != null)
                return false;
        }
        else if (!this.publicKeyPath.equals(other.publicKeyPath))
            return false;
        if (this.getPublicKey == null) {
            if (other.getPublicKey != null)
                return false;
        }
        else if (!this.getPublicKey.equals(other.getPublicKey))
            return false;
        if (this.networkNamespace == null) {
            if (other.networkNamespace != null)
                return false;
        }
        else if (!this.networkNamespace.equals(other.networkNamespace))
            return false;
        if (this.compressionAlgorithm == null) {
            if (other.compressionAlgorithm != null)
                return false;
        }
        else if (!this.compressionAlgorithm.equals(other.compressionAlgorithm))
            return false;
        if (this.zstdCompressionLevel == null) {
            if (other.zstdCompressionLevel != null)
                return false;
        }
        else if (!this.zstdCompressionLevel.equals(other.zstdCompressionLevel))
            return false;
        if (this.tlsCiphersuites == null) {
            if (other.tlsCiphersuites != null)
                return false;
        }
        else if (!this.tlsCiphersuites.equals(other.tlsCiphersuites))
            return false;
        if (this.sourceConnectionAutoFailover == null) {
            if (other.sourceConnectionAutoFailover != null)
                return false;
        }
        else if (!this.sourceConnectionAutoFailover.equals(other.sourceConnectionAutoFailover))
            return false;
        if (this.gtidOnly == null) {
            if (other.gtidOnly != null)
                return false;
        }
        else if (!this.gtidOnly.equals(other.gtidOnly))
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((this.channelName == null) ? 0 : this.channelName.hashCode());
        result = prime * result + ((this.host == null) ? 0 : this.host.hashCode());
        result = prime * result + ((this.port == null) ? 0 : this.port.hashCode());
        result = prime * result + ((this.user == null) ? 0 : this.user.hashCode());
        result = prime * result + ((this.networkInterface == null) ? 0 : this.networkInterface.hashCode());
        result = prime * result + ((this.autoPosition == null) ? 0 : this.autoPosition.hashCode());
        result = prime * result + ((this.sslAllowed == null) ? 0 : this.sslAllowed.hashCode());
        result = prime * result + ((this.sslCaFile == null) ? 0 : this.sslCaFile.hashCode());
        result = prime * result + ((this.sslCaPath == null) ? 0 : this.sslCaPath.hashCode());
        result = prime * result + ((this.sslCertificate == null) ? 0 : this.sslCertificate.hashCode());
        result = prime * result + ((this.sslCipher == null) ? 0 : this.sslCipher.hashCode());
        result = prime * result + ((this.sslKey == null) ? 0 : this.sslKey.hashCode());
        result = prime * result + ((this.sslVerifyServerCertificate == null) ? 0 : this.sslVerifyServerCertificate.hashCode());
        result = prime * result + ((this.sslCrlFile == null) ? 0 : this.sslCrlFile.hashCode());
        result = prime * result + ((this.sslCrlPath == null) ? 0 : this.sslCrlPath.hashCode());
        result = prime * result + ((this.connectionRetryInterval == null) ? 0 : this.connectionRetryInterval.hashCode());
        result = prime * result + ((this.connectionRetryCount == null) ? 0 : this.connectionRetryCount.hashCode());
        result = prime * result + ((this.heartbeatInterval == null) ? 0 : this.heartbeatInterval.hashCode());
        result = prime * result + ((this.tlsVersion == null) ? 0 : this.tlsVersion.hashCode());
        result = prime * result + ((this.publicKeyPath == null) ? 0 : this.publicKeyPath.hashCode());
        result = prime * result + ((this.getPublicKey == null) ? 0 : this.getPublicKey.hashCode());
        result = prime * result + ((this.networkNamespace == null) ? 0 : this.networkNamespace.hashCode());
        result = prime * result + ((this.compressionAlgorithm == null) ? 0 : this.compressionAlgorithm.hashCode());
        result = prime * result + ((this.zstdCompressionLevel == null) ? 0 : this.zstdCompressionLevel.hashCode());
        result = prime * result + ((this.tlsCiphersuites == null) ? 0 : this.tlsCiphersuites.hashCode());
        result = prime * result + ((this.sourceConnectionAutoFailover == null) ? 0 : this.sourceConnectionAutoFailover.hashCode());
        result = prime * result + ((this.gtidOnly == null) ? 0 : this.gtidOnly.hashCode());
        return result;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("ReplicationConnectionConfiguration (");

        sb.append(channelName);
        sb.append(", ").append(host);
        sb.append(", ").append(port);
        sb.append(", ").append(user);
        sb.append(", ").append(networkInterface);
        sb.append(", ").append(autoPosition);
        sb.append(", ").append(sslAllowed);
        sb.append(", ").append(sslCaFile);
        sb.append(", ").append(sslCaPath);
        sb.append(", ").append(sslCertificate);
        sb.append(", ").append(sslCipher);
        sb.append(", ").append(sslKey);
        sb.append(", ").append(sslVerifyServerCertificate);
        sb.append(", ").append(sslCrlFile);
        sb.append(", ").append(sslCrlPath);
        sb.append(", ").append(connectionRetryInterval);
        sb.append(", ").append(connectionRetryCount);
        sb.append(", ").append(heartbeatInterval);
        sb.append(", ").append(tlsVersion);
        sb.append(", ").append(publicKeyPath);
        sb.append(", ").append(getPublicKey);
        sb.append(", ").append(networkNamespace);
        sb.append(", ").append(compressionAlgorithm);
        sb.append(", ").append(zstdCompressionLevel);
        sb.append(", ").append(tlsCiphersuites);
        sb.append(", ").append(sourceConnectionAutoFailover);
        sb.append(", ").append(gtidOnly);

        sb.append(")");
        return sb.toString();
    }
}
